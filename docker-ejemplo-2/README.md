# docker-ejemplo-2 üöÄ

> **Nueva arquitectura: Tres contenedores en red interna (un server y dos clients) para simular un entorno distribuido y probar concurrencia real.**

---

## üèóÔ∏è Arquitectura de deployment

Este ejemplo est√° dise√±ado para mostrar c√≥mo desplegar una aplicaci√≥n distribuida usando Docker Compose con una red interna y tres contenedores:

- **server**: Un contenedor que ejecuta un servidor Flask (basado en main.py), expone una API REST para agregar y listar tareas (persistidas en tasks.json).
- **client1**: Un contenedor que ejecuta test_operacional.py, el cual interact√∫a con el server v√≠a HTTP usando la librer√≠a requests. Este cliente emula el env√≠o de 100 tareas concurrentes al servidor.
- **client2**: Otro contenedor id√©ntico a client1, que tambi√©n emula el env√≠o de 100 tareas concurrentes al servidor.
- Los tres contenedores se comunican √∫nicamente a trav√©s de una red interna de Docker definida por docker-compose, sin exponer puertos al host (a menos que quieras acceder a la API desde fuera para pruebas).

El objetivo es emular un escenario donde dos clientes independientes env√≠an muchas tareas al mismo tiempo al servidor, para verificar si el server es capaz de recibir y guardar todas las tareas sin perder ninguna (por condiciones de carrera, concurrencia, etc).

### Requisitos previos
- Tener instalado Docker y Docker Compose.
- No es necesario exponer puertos a la m√°quina host, salvo que quieras acceder a la API desde fuera.
- El archivo docker-compose.yml orquesta los tres servicios y la red interna.

### ¬øC√≥mo se crea la red interna?

Cuando ejecutas `docker-compose up`, Docker Compose crea autom√°ticamente una red interna (bridge) exclusiva para los servicios definidos en el archivo `docker-compose.yml`.

- Todos los contenedores definidos (server, client1, client2) se conectan a esa red y pueden comunicarse entre s√≠ usando el nombre del servicio como hostname (por ejemplo, `server:9000`).
- No necesitas crear la red manualmente ni exponer puertos al host (a menos que quieras acceder desde fuera).
- La comunicaci√≥n entre contenedores es privada y segura dentro de esa red.

Esto permite que los clientes puedan hacer peticiones HTTP al servidor simplemente usando la URL `http://server:9000/` desde su propio contenedor.

---

## üîÑ Cambios de arquitectura respecto al ejemplo original

En esta versi√≥n, la arquitectura fue redise√±ada para simular un entorno distribuido y robusto, ideal para pruebas de concurrencia y despliegue realista:

- **Separaci√≥n de responsabilidades:**
  - El c√≥digo se divide en dos roles principales:
    - **server:** Un contenedor dedicado a ejecutar un servidor Flask que expone una API REST para agregar y listar tareas.
    - **clients (client1 y client2):** Contenedores independientes que ejecutan test_operacional.py, enviando tareas concurrentemente al server v√≠a HTTP.

- **Comunicaci√≥n por red interna Docker:**
  - Los contenedores se comunican exclusivamente a trav√©s de una red interna creada autom√°ticamente por Docker Compose.
  - Los clients acceden al server usando su nombre de servicio como hostname (por ejemplo, `http://server:9000`).

- **API REST y concurrencia real:**
  - El server ya no depende de la entrada por consola, sino que expone endpoints HTTP para recibir tareas desde cualquier cliente.
  - Los clients pueden ejecutarse en paralelo y desde diferentes contenedores, simulando usuarios o sistemas independientes.

- **Motivaci√≥n de los cambios:**
  - Permitir pruebas de concurrencia y condiciones de carrera en un entorno distribuido real.
  - Facilitar la escalabilidad y la integraci√≥n con otros sistemas o microservicios.
  - Demostrar buenas pr√°cticas de despliegue y comunicaci√≥n entre servicios en Docker.

---

## üèóÔ∏è Evoluci√≥n de arquitectura: Monol√≠tica ‚Üí Distribuida

A continuaci√≥n se muestra c√≥mo cambi√≥ la arquitectura del sistema:

**Arquitectura Monol√≠tica (original):**

```
+---------------------+
|   test_operacional  |
|     (simula users)  |
+---------------------+
           |
           v (subproceso)
+---------------------+
|      main.py        |
| (agrega/lista tareas|
|   en consola)       |
+---------------------+
           |
           v (escribe/lee)
+---------------------+
|    tasks.json       |
+---------------------+
```

**Arquitectura Distribuida (actual):**

```
+---------------------+      HTTP POST/GET      +---------------------+
|  clientemulator.py  |-----------------------> |   taskserver.py     |
|    (client1)        |                         |   (Flask API)       |
+---------------------+                         +---------------------+
                                                |  acceso seguro a    |
+---------------------+      HTTP POST/GET      |    tasks.json       |
|  clientemulator.py  |-----------------------> |  (persistencia)     |
|    (client2)        |                         +---------------------+
+---------------------+
```

**Resumen:**
- Antes: Todo ocurr√≠a en un solo proceso, con acceso directo al archivo.
- Ahora: Los clientes son procesos independientes (incluso en contenedores distintos), que se comunican con el servidor por HTTP, y el servidor es el √∫nico que accede al archivo de manera segura.

---

## üìÇ Archivos principales

| Archivo                | Descripci√≥n                                                        |
|------------------------|--------------------------------------------------------------------|
| `taskserver.py`        | Aplicaci√≥n principal (servidor Flask) para agregar y listar tareas (`tasks.json`).   |
| `Dockerfile`           | Archivo para contenerizar la aplicaci√≥n.                           |
| `clientemulator.py`    | Script que simula el env√≠o masivo de tareas desde cada cliente.    |
| `docker-compose.yml`   | Orquestador de los tres servicios y la red interna.                |

---

## üê≥ Instalaci√≥n de Docker

### macOS

1. Descarga e instala [Docker Desktop para Mac](https://www.docker.com/products/docker-desktop/).
2. Abre el archivo `.dmg` descargado y arrastra Docker a tu carpeta de Aplicaciones.
3. Inicia Docker Desktop desde Aplicaciones y espera a que el icono de Docker est√© activo en la barra de men√∫.
4. Verifica la instalaci√≥n abriendo una terminal y ejecutando:
   ```sh
   docker --version
   ```
---

## üñ•Ô∏è Uso local (solo para pruebas r√°pidas)

1. Ejecuta la aplicaci√≥n:
   ```sh
   python main.py
   ```
2. Sigue las instrucciones para agregar o listar tareas.

---

## üê≥ Uso con Docker Compose (recomendado)

1. **Construye y levanta los servicios:**
   ```sh
   docker-compose up --build
   ```
   Esto levantar√° el server y ambos clientes en la misma red interna.

2. **Observa los logs:**
   - El server mostrar√° las tareas que va recibiendo.
   - Cada cliente enviar√° 100 tareas y mostrar√° el resultado de sus env√≠os.

3. **Verifica el resultado:**
   - Al finalizar, deber√≠as ver en el server un total de 200 tareas (100 de cada cliente).
   - Puedes inspeccionar el archivo `tasks.json` dentro del contenedor server para comprobar que no se perdi√≥ ninguna tarea.

---

## üê≥ Ingresar a un contenedor en ejecuci√≥n

Si necesitas ingresar a alguno de los contenedores (por ejemplo, al server para ver el archivo de tareas):

1. **Lista los contenedores activos:**
   ```sh
   docker ps
   ```
2. **Ingresa al contenedor server:**
   ```sh
   docker exec -it docker-ejemplo-2-server-1 /bin/bash
   ```
   (El nombre puede variar seg√∫n tu configuraci√≥n de docker-compose.)

3. **Dentro del contenedor server**, puedes ejecutar comandos como:
   - Listar archivos:
     ```sh
     ls
     ```
   - Ver el contenido de tasks.json:
     ```sh
     cat /app/tasks.json
     ```
   - Ejecutar la aplicaci√≥n principal (si es necesario):
     ```sh
     python /app/main.py
     ```

4. **Para salir** de la terminal del contenedor, escribe "exit" o presiona Ctrl+D.

---

## üß™ Prueba operacional distribuida

Para simular la concurrencia real y verificar si el server pierde tareas:

- Cada cliente (client1 y client2) enviar√° 100 tareas al server usando la API REST.
- El server debe recibir y guardar las 200 tareas (100 de cada cliente) en `tasks.json`.
- Al finalizar, revisa el total de tareas registradas en el server.

### Diferencia: ¬øPor qu√© podr√≠an perderse tareas? (Condiciones de carrera y concurrencia)

Cuando varios clientes (contenedores) intentan agregar tareas al mismo tiempo, el servidor debe manejar correctamente la concurrencia. Si dos o m√°s procesos intentan escribir en el archivo `tasks.json` simult√°neamente y no hay un mecanismo de protecci√≥n (como un bloqueo de archivo), pueden ocurrir **condiciones de carrera**.

- **Condici√≥n de carrera:** Es un problema que ocurre cuando el resultado de una operaci√≥n depende del orden o la sincronizaci√≥n de m√∫ltiples procesos o hilos. En este caso, si dos clientes escriben al mismo tiempo, una escritura puede sobrescribir a la otra y se pierden tareas.
- **Ejemplo:** Si client1 y client2 env√≠an tareas al mismo tiempo y el servidor no protege el acceso al archivo, puede que solo se guarden algunas de las tareas, y el total final sea menor a la suma esperada (por ejemplo, menos de 200).
- **Soluci√≥n:** El servidor debe implementar un mecanismo de bloqueo (file lock) para asegurar que solo un proceso escriba en el archivo a la vez, evitando as√≠ la p√©rdida de datos.

**En resumen:**
- Si el servidor maneja bien la concurrencia, no se pierde ninguna tarea.
- Si hay condiciones de carrera, el total de tareas guardadas ser√° menor al esperado.

---

## üß™ Explicaci√≥n de la prueba

- **Concurrencia real:**  
  Al tener dos contenedores clientes independientes, ambos pueden enviar tareas al mismo tiempo, simulando un entorno distribuido real.
- **clientemulator.py:**  
  Cada cliente ejecuta este script, que env√≠a 100 tareas al server usando peticiones HTTP (requests).
- **Verificaci√≥n:**  
  Si el server maneja correctamente la concurrencia y el acceso al archivo, no se perder√° ninguna tarea. Si hay problemas de concurrencia, el total ser√° menor a 200.

---

## üìù Notas

- Puedes modificar el n√∫mero de tareas enviadas por cada cliente editando `clientemulator.py`.
- Este ejemplo es ideal para practicar **despliegue distribuido**, **persistencia de datos concurrente** y **pruebas de robustez operacional** usando Docker Compose.
- Si tienes dudas, revisa la documentaci√≥n oficial de [Docker](https://docs.docker.com/).

---

## üìö Recursos √∫tiles

- [Gu√≠a oficial de Docker para Python](https://docs.docker.com/guides/python/containerize/)
- [Full Stack Python: Docker](https://www.fullstackpython.com/docker.html)
- [Documentaci√≥n de Docker Compose](https://docs.docker.com/compose/)

---

## üõ†Ô∏è Resoluci√≥n de errores comunes

### 1. ModuleNotFoundError: No module named 'requests'

**Causa:** Falta instalar la librer√≠a `requests` dentro del contenedor Docker.

**Soluci√≥n:**
- Aseg√∫rate de tener un archivo `requirements.txt` con el contenido:
  ```
  requests
  ```
- Modifica el `Dockerfile` para instalar las dependencias:
  ```dockerfile
  COPY requirements.txt /app/
  RUN pip install --no-cache-dir -r requirements.txt
  ```

---

### 2. ERROR: docker: 'docker buildx build' requires 1 argument

**Causa:** Olvidaste poner el punto (`.`) al final del comando `docker build`.

**Soluci√≥n:**
- Usa el comando completo:
  ```sh
  docker build -t docker-ejemplo .
  ```
  (¬°No olvides el punto al final!)

---

### 3. sudo: apt: command not found

**Causa:** Est√°s usando comandos de Linux (Ubuntu) en macOS, donde no existe `apt`.

**Soluci√≥n:**
- En macOS, instala Docker siguiendo solo los pasos de la secci√≥n "macOS" del README. No uses comandos `apt` en Mac.

---

## üê≥ Dockerfile multi-rol y uso con Docker Compose

- El Dockerfile est√° dise√±ado para servir tanto al server como a los clientes:
  - Por defecto, ejecuta `python taskserver.py` (el servidor Flask).
  - Cuando se usa en los servicios de cliente, Docker Compose sobreescribe el comando para ejecutar `python clientemulator.py`.
- As√≠, se reutiliza la misma imagen para todos los servicios, facilitando el mantenimiento y la construcci√≥n.
- El archivo `requirements.txt` incluye tanto Flask (para el server) como requests (para los clientes).

En el archivo `docker-compose.yml` se define qu√© comando ejecuta cada servicio.

---

## üìÑ Ejemplo de docker-compose.yml

```yaml
version: '3.8'
services:
  server:
    build: .
    container_name: taskserver
    restart: unless-stopped
    networks:
      - ticsnet
    volumes:
      - ./tasks.json:/app/tasks.json
    # Exponer el puerto solo si quieres acceder desde fuera
    ports:
      - "9000:9000"
  client1:
    build: .
    command: ["python", "clientemulator.py"]
    depends_on:
      - server
    networks:
      - ticsnet
  client2:
    build: .
    command: ["python", "clientemulator.py"]
    depends_on:
      - server
    networks:
      - ticsnet
networks:
  ticsnet:
    driver: bridge
```

- **server**: Levanta el servidor Flask en el puerto 9000 y monta el archivo de tareas para persistencia.
- **client1 y client2**: Ejecutan el emulador de cliente, enviando tareas concurrentemente al server.
- Todos los servicios usan la misma imagen, pero los clientes sobreescriben el comando para ejecutar el emulador.
- Todos los servicios est√°n en la red interna `ticsnet` y pueden comunicarse usando los nombres de servicio.

---

## üö¶ Gu√≠a r√°pida de prueba

1. (Opcional) Limpia el archivo de tareas antes de comenzar:
   ```sh
   echo "[]" > tasks.json
   ```

2. Levanta todos los servicios (server y clientes):
   ```sh
   docker-compose up --build
   ```
   - Observa los logs para ver c√≥mo los clientes env√≠an tareas concurrentemente al server.

3. (Opcional) Ingresa al contenedor del server para inspeccionar el archivo de tareas:
   ```sh
   docker exec -it taskserver /bin/bash
   cat /app/tasks.json
   ```

4. Para salir del contenedor, escribe:
   ```sh
   exit
   ```
   o presiona `Ctrl+D`.

5. (Opcional) Cuando termines, baja todos los servicios:
   ```sh
   docker-compose down
   ```

---

## üëÄ Monitoreo y verificaci√≥n de los contenedores y la red

### 1. Ver los contenedores activos
```sh
docker ps
```

### 2. Ver los logs de todos los servicios en tiempo real
```sh
docker-compose logs -f
```
- Para ver solo los logs de un servicio espec√≠fico:
  ```sh
  docker-compose logs -f server
  ```

### 3. Verificar que los contenedores est√°n en la red privada
```sh
docker network ls
```
Busca el nombre de la red (por ejemplo, `docker-ejemplo-2_ticsnet`), luego:
```sh
docker network inspect docker-ejemplo-2_ticsnet
```
Ver√°s los contenedores conectados a esa red.

### 4. Ver el estado de los servicios en Compose
```sh
docker-compose ps
```

### 5. (Opcional) Ver los procesos dentro de un contenedor
```sh
docker exec -it taskserver ps aux
```

---

## üé§ Gu√≠a para c√°psula de 5 minutos: Explicaci√≥n de la arquitectura distribuida

### 1. ¬øDe qu√© trata el problema?
- Simular un sistema de gesti√≥n de tareas donde m√∫ltiples clientes agregan tareas concurrentemente a un servidor.
- El objetivo es probar la robustez y la persistencia de datos bajo concurrencia real, como ocurrir√≠a en sistemas distribuidos.

### 2. ¬øC√≥mo fue dise√±ado?
- Se rearquitectur√≥ el sistema original monol√≠tico a una arquitectura distribuida usando Docker Compose.
- Ahora hay tres contenedores:
  - **taskserver.py**: Servidor Flask que expone una API REST para agregar y listar tareas.
  - **clientemulator.py (client1 y client2)**: Clientes que simulan usuarios enviando tareas concurrentemente al server v√≠a HTTP.
- Todos los contenedores se comunican solo por una red interna de Docker.

### 3. ¬øQu√© mostrar del c√≥digo o README?
- Abre el README y muestra:
  - El diagrama ASCII de la evoluci√≥n de arquitectura.
  - La secci√≥n de arquitectura de deployment y el ejemplo de docker-compose.yml.
- Abre `taskserver.py` y muestra los endpoints Flask (`/tareas` GET y POST) y el uso de file lock.
- Abre `clientemulator.py` y muestra c√≥mo se env√≠an tareas concurrentemente usando requests y threads.

### 4. ¬øC√≥mo se levanta el sistema?
- (Opcional) Limpia el archivo de tareas:
  ```sh
  echo "[]" > tasks.json
  ```
- Levanta los servicios:
  ```sh
  docker-compose up --build
  ```

### 5. ¬øQu√© pasa y qu√© revisar?
- Observa los logs en tiempo real:
  - Los clientes env√≠an tareas concurrentemente.
  - El server recibe y guarda las tareas en `tasks.json`.
- Verifica el archivo de tareas:
  ```sh
  docker exec -it taskserver /bin/bash
  cat /app/tasks.json
  exit
  ```
- Espera ver el n√∫mero total de tareas igual a la suma de las enviadas por ambos clientes (por ejemplo, 200).

### 6. ¬øQu√© espero y qu√© demuestro?
- Que todas las tareas se guardan correctamente (no hay p√©rdida por condiciones de carrera).
- Que la comunicaci√≥n es solo interna: los clientes y el server solo se ven entre s√≠ dentro de la red privada de Docker.
- Si intentas acceder a la API desde fuera (sin exponer el puerto), no es posible.
- Puedes mostrar la red interna y los contenedores conectados con:
  ```sh
  docker network inspect docker-ejemplo-2_ticsnet
  ```

--- 